# Page Table

## Sv39 RISC-V的多级页表

> 参考：[SV39 多级页表的硬件机制](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html)

Sv39 RISC-V中，虚拟内存有64位，但是只有低39位可以用来寻址。虚拟内存使用的核心寄存器是`satp`寄存器，长度为8字节，具体结构如下

![](https://rcore-os.github.io/rCore-Tutorial-Book-v3/_images/satp.png)

- `MODE` ：控制 CPU 使用哪种寻址策略，如果此值被设定为0，则代表所有访问均是物理内存地址，当被设定为8时，SV39才会启动分页内存机制。
- `ASID` ：表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；
- `PPN` ：进程进行内存映射需要映射页表，这个页表并不是单纯的一张表格，出于节省内存的考量，这张用作内存映射的表格常被以树的形式存储，这里存储的就是这棵树的root。

虚拟地址和物理地址的具体结构如下

<img src="https://rcore-os.github.io/rCore-Tutorial-Book-v3/_images/sv39-va-pa.png" style="zoom:67%;" /> 

> 为何Sv39分页的RISC-V是39位虚拟地址？
>
> 在64位的RISC-V架构上，虚拟地址确实应该和位宽一致，均为64位，但是对于Sv39分页而言只有低39位是有意义的，SV39 分页模式规定 64 位虚拟地址的 [63:39] 这 25 位必须和第 38 位相同，否则会被认定为是一个不合法的虚拟地址。
>
> 也就是说，所有 264 个虚拟地址中，只有最低的 256GiB （当第 38 位为 0 时）以及最高的 256GiB （当第 38 位为 1 时）是可能通过 MMU 检查的。当我们写软件代码的时候，一个地址的位宽毋庸置疑就是 64 位，我们要清楚可用的只有最高和最低这两部分

虚拟地址的[38:12]位标识用于区分page，而[11:0]位用于标识地址在具体的page中的位置。（个人猜测这样划分page的依据是使得page尽可能的多，并且剩余的位数也刚好可以完成对page的内部寻址，达到没有冗余位的作用），也就是说逻辑上最多可以拥有2^27个分页表，这个Virtual Page也被称为page table entrie，也就是PTEs，每一个PTE为56位，也就是物理内存，其中高44位用于标识物理分页的位置physical page number (PPN)，后续内容为在这个physical page中的具体位置。

也就是说，通过Page Table，将39位虚拟内存映射为了56位物理内存。每4096 byte的内存单元组成

> 为什么是4096 byte？首先，PTE的offset是12位，也就代表着在单个page拥有2^12=4096个寻址，而这些寻址对应的并不是bit，操作的下限是byte，单个page掌控4096 byte的物理内存也就因此而来。
>
>  page table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096 (2^12) bytes. Such a chunk is called a page.

具体的对应关系如下

<img src="https://github.com/RayleighZ/ImageBed/blob/master/virtualAddress.png?raw=true" style="zoom: 33%;" /> 

低39位构成了Sv39的具有实际含义的虚拟内存地址，其中前27位构成了PTE寻址，在总大小为2^27的PTEs中找到对应的某一个PTE，单个PTE指向共4096 byte的内存空间，VA具体对应的PA需要在PTE中通过offset进行标识。

下讨论为什么要使用分级页表（参考文章：[多级页表如何节约内存 ](https://www.polarxiong.com/archives/多级页表如何节约内存.html)）

试考虑一个问题，这样的页表将会占用多大的内存？假设虚拟地址空间为32位，总计有4GB的内存需要映射。然后OS的细粒度划分为4096 byte，也就是4KB，这样的话需要4GB÷4KB=1M的PTE。假设一条PTE长度为4B，则总页表大小为4MB。对于每一个进程而言都需要作此划分，未免开销过大。

如果采用分页内存，从表面上似乎问题并没有得到解决，假设采用二级分页，每一个一级PTE可以控制4096 KB的空间，如果用这些存储二级分页的PTE，则一个一级PTE可以存储1K个二级PTE，故总计需要4GB÷4KB=1M的二级PTE，和1M÷1K=1K的以及PTE，占用的总内存为4MB+4KB，相较前者甚至多出了4KB的内存占用。

多级页表能节约内存并不表现在完备映射之后内存占用少于不分级，而是体现在以下两个方面：1、二级页表可以不存在；2、二级页表可以不在主存

> * 二级页表可以不存在：不同的进程拥有不同的虚拟内存，32位虚拟内存可以提供4GB的运行空间，但并不是所有程序均需如此多的内存，故可以先只映射一部分内存。比如上例中，一级页表可以假装Handle了4GB的内存，但是实际上很多部分的二级页表并没有被实例化，因为高概率程序用不到，可以在程序需要的时候再创建，就可以减少内存占用。为什么不分级就不能这样？个人认为是OS没有操作空间，分集之后通过MMU寻址是去找OS写入的一级页表，寻址的话是可以寻址到的，只不过再从一级页表找到二级页表的时候需要OS解决一下映射问题，但是如果不分级，将直接寻址不到。
> * 二级页表可以不存在于主存：可以将内存页表存储在磁盘中，等到需要的时候再从磁盘中读取。为什么不分级做不到磁盘存储的原因应该是和二级页表可以不存在的原理相同。

多级页表的使用方案如下所示（图示为3级分页内存），L2中的9 bit地址标识再root（stap）所指中的虚拟PTE位置，从L2的寻址中，可以找到第二集页表的位置，L1对应的就是二级页表中的PTE位置，之后以此类推，知道第三级才最终指向PA。

<img src="https://rcore-os.github.io/rCore-Tutorial-Book-v3/_images/sv39-full.png" style="zoom: 50%;" /> 



每条PTE中均含有FLAG位，具体功能在The Book中介绍如下（大概就是：是否真的存在映射，进程是否可读，进程是否可写啥的）

PTE_V indicates whether the PTE is present: if it is not set, a reference to the page causes an exception (i.e. is not allowed). PTE_R controls whether instructions are allowed to read to the page. PTE_W controls whether instructions are allowed to write to the page. PTE_X controls whether the CPU may interpret the content of the page as instructions and execute them. PTE_U controls whether instructions in user mode are allowed to access the page; if PTE_U is not set, the PTE can be used only in supervisor mode.

关于satp寄存器，the book中是如此介绍的（此处的CPU应当做核心理解，如果cpu中的核心公用一个satp，多进程处理真正的并行将不好实现）

To tell the hardware to use a page table, the kernel must write the physical address of the root page-table page into the satp register. Each CPU has its own satp. A CPU will translate all addresses generated by subsequent instructions using the page table pointed to by its own satp.
