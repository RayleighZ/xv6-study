# OS ç®€ä»‹ä¸ç›¸å…³æ¥å£

## OSçš„åŸºæœ¬åŠŸèƒ½

OSæ‰€å¤„çš„ä½ç½®åœ¨æŒ‡ä»¤é›†ä¹‹ä¸Šï¼Œåœ¨åº”ç”¨å±‚ä¹‹ä¸‹ï¼ŒåŸºäºæŒ‡ä»¤é›†ï¼Œä¿è¯åº”ç”¨ç¨‹å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œå¹¶ä¸ºåº”ç”¨æä¾›æ›´åŠ é«˜æ•ˆæœ‰ç”¨çš„æ¥å£ï¼Œè¿™å°±æ˜¯OSçš„æ ¸å¿ƒä½œç”¨ã€‚

> æŒ‡ä»¤é›†(ISA)ï¼šåŒºåˆ«äºæœ€åŸºç¡€çš„ä½è¿ç®—å’Œå¯„å­˜å™¨æ“ä½œï¼Œç°ä»£å¤„ç†å™¨ä¸ºäº†æ–¹ä¾¿åº•å±‚å¼€å‘ï¼Œä¼šå°†å¤§é‡çš„å¸¸ç”¨æŒ‡ä»¤é›†å’Œæ•´åˆä¸ºç»Ÿä¸€çš„æŒ‡ä»¤ï¼Œç§°ä¹‹ä¸ºæŒ‡ä»¤é›†ï¼Œæ˜¯æ±‡ç¼–çš„ç³»ç»Ÿé›†åˆä¸æ„æˆã€‚

æ ¹æ®é¢å‘å¯¹è±¡çš„è®¾è®¡æ€æƒ³ï¼Œåœ¨ä¸åŒå±‚çº§ä¹‹é—´äº¤äº’çš„æ—¶å€™ï¼Œä½¿ç”¨çš„åº”è¯¥æ˜¯æ¥å£ï¼Œè€Œæ¥å£è‡ªç„¶è€Œç„¶çš„å…·å¤‡æŠ½è±¡çš„ç‰¹æ€§ï¼Œå¯¹äº**åº”ç”¨å±‚**è€Œè¨€ï¼ŒOSå¯¹*ç¡¬ä»¶å±‚*è¿›è¡Œäº†æŠ½è±¡ï¼Œä¸¾ä¸ªä¾‹å­ï¼šä¸€ä¸ªç°ä»£æ“ä½œç³»ç»Ÿåº”å½“å…·å¤‡å¤šè¿›ç¨‹æ”¯æŒï¼Œæ•…éœ€è¦å¯¹CPUçš„æ—¶é—´ç‰‡è¿›è¡Œåˆç†åˆ†é…ï¼Œä½¿å¾—ä¸åŒçš„è¿›ç¨‹éƒ½å¯ä»¥å¾—åˆ°æ—¶é—´è¿è¡Œï¼Œè¿›è€Œè¾¾åˆ°å¤šè¿›ç¨‹æ”¯æŒï¼Œä½†æ˜¯CPUå¤šç§å¤šæ ·ï¼Œå¤šæ ¸CPUï¼Œå•æ ¸CPUï¼Œå¤§å°æ ¸CPUçš„æ ¸å¿ƒè°ƒåº¦ç­–ç•¥ç†åº”ä¸åŒï¼Œè€Œåœ¨åº”ç”¨å±‚çš„åº”ç”¨å¹¶ä¸éœ€è¦äº†è§£è¿™äº›ï¼ŒOSå°†å¯¹ä¸Šè¿°ä¸€åˆ‡è¿›è¡ŒæŠ½è±¡ï¼Œåº”ç”¨åªéœ€è¦çŸ¥é“å®ƒä¸€å®šå¯ä»¥è¢«æ‰§è¡Œåˆ°å°±å¯ä»¥äº†ã€‚

## å¸¸è§çš„System Callæä¾›æ–¹å¼

* å¾®å†…æ ¸ï¼šéƒ¨åˆ†çš„System Callè¿è¡Œåœ¨User Spaceï¼Œéƒ¨åˆ†è¿è¡Œåœ¨Kernel Spaceï¼Œè¿™æ ·åšçš„ä¼˜ç‚¹åœ¨äºå‡å°‘äº†Kernelçš„å†—æ‚åº¦ï¼Œé™ä½äº†Kernel Spaceçš„è´Ÿæ‹…ï¼Œç†è®ºä¸Šå¯ä»¥å‡å°‘å†…æ ¸æŠ¥é”™çš„æ¦‚ç‡ã€‚
* å¸¸è§„å†…æ ¸ï¼šæ‰€æœ‰System Callå‡è¿è¡Œåœ¨Kernel Spaceï¼Œè®¾è®¡ç®€å•ï¼Œprocesséš”ç¦»ç®€å•ï¼Œç›®å‰Linuxå°±å¤„äºè¿™ç§æ¨¡å¼ã€‚

## fork()è¯¦ç»†åˆ†æ

forkçš„ä½œç”¨æ˜¯å°†è¿›ç¨‹å¤åˆ¶ï¼Œå¤åˆ¶çš„å†…å®¹å‡ ä¹è¿›ç¨‹çš„å…¨éƒ¨ï¼ˆpidé™¤å¤–ï¼‰ï¼Œä½†æ˜¯å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå­è¿›ç¨‹å¤åˆ¶è¿‡åçš„å†…å­˜è™½ç„¶å’Œçˆ¶è¿›ç¨‹å†…å®¹ä¸Šç›¸ä¼¼ï¼ˆcontains the sameï¼‰ï¼Œä½†æ˜¯å®é™…ä¸Šå­˜å‚¨çš„å†…å­˜ä½ç½®å’Œè¿›ç¨‹è°ƒç”¨çš„å¯„å­˜å™¨ä½ç½®æ˜¯å®Œå…¨ä¸åŒçš„ï¼Œä¹Ÿå°±æ˜¯å†…å®¹ä¸Šçš„å¤åˆ¶ï¼Œä½†æ˜¯å®é™…æŒ‡é’ˆï¼ˆå†…å­˜ä¸­çš„å­˜å‚¨ä½ç½®ï¼‰æ˜¯ä¸¤ä¸ªã€‚

> changing a variable in one does not affect the other

### forkçš„åŒè¿”å›å€¼

forkçš„è¿”å›å€¼ï¼šå¦‚æœæ˜¯çˆ¶è¿›ç¨‹ï¼Œåˆ™è¿”å›å€¼ä¸ºå­è¿›ç¨‹idï¼Œå¦‚æœæ˜¯å­è¿›ç¨‹ï¼Œåˆ™è¿”å›å€¼ä¸º0ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœè¿›è¡Œä¸€æ¬¡forkï¼Œå°†ä¼šå‡ºç°ä¸¤æ¬¡è¿”å›ï¼Œè¿™æ˜¯å› ä¸ºåœ¨forkçš„è¿‡ç¨‹ä¸­ï¼Œè¿›ç¨‹çš„ç¨‹åºè®¡æ•°å™¨åŒæ ·ä¼šè¢«å¤åˆ¶ï¼Œå½“å­è¿›ç¨‹è¢«å¤åˆ¶ä¹‹åï¼Œå’Œçˆ¶è¿›ç¨‹ä¸€æ ·ï¼Œç¨‹åºè®¡æ•°å™¨éƒ½å¤„åœ¨forkä¹‹ä¸­ï¼Œæ•…ä»å®è§‚ä¸Šè®²ï¼Œåœ¨æ•´ä¸ªOSä¸­å°†ä¼šæœ‰ä¸¤ä¸ªç¨‹åºè®¡æ•°å™¨æŒ‡å‘forkå‡½æ•°ä¹‹ä¸­ï¼Œå°±ä¼šæœ‰ä¸¤æ¬¡forkçš„è¿”å›å€¼ã€‚

## exec()è¯¦ç»†åˆ†æ

execä½œç”¨æ˜¯å°†ç‰¹å®šçš„ç¨‹åºå†…å­˜imageæ›¿æ¢æ‰å½“å‰çš„processå†…å­˜ã€‚å…¶ä¸­çš„å†…å­˜imageæ˜¯ä»fileä¸­è¯»å–çš„ï¼Œè¿™å°±è¦æ±‚fileéœ€è¦å…·å¤‡ä¸€å®šçš„æ ¼å¼ï¼Œç±»ä¼¼äºç¼–ç¨‹è¯­è¨€ä¸­è¦æ±‚è¦æœ‰ä¸€å®šçš„æ–‡æ³•è§„åˆ™ä¸€æ ·ï¼Œåœ¨xv6ä¸­é‡‡ç”¨çš„æ˜¯ELFï¼ˆå¯æ‰§è¡Œä¸å¯é“¾æ¥ï¼‰æ–‡ä»¶æ ¼å¼

> ELFä¸cçš„ç¼–è¯‘è¿‡ç¨‹ï¼ˆå°±ä¸è¯¦ç»†çš„å­¦ä¹ ç¼–è¯‘åŸç†è¯¾ç¨‹äº†
>
> Cè¯­è¨€çš„æ‰§è¡Œæµç¨‹ä¸ºï¼š
>
> * é¢„å¤„ç†é˜¶æ®µï¼ˆCPPï¼‰ï¼šä¸»è¦è¿›è¡Œæ–‡æœ¬æ›¿æ¢ã€å®å±•å¼€å’Œæ³¨é‡Šåˆ é™¤ã€‚äº§ç”Ÿ.iæ–‡ä»¶ï¼ˆæ–‡æœ¬æ–‡ä»¶ï¼‰
> * ç¼–è¯‘é˜¶æ®µï¼šå°†æ–‡æœ¬æ–‡ä»¶ç¼–è¯‘äº§ç”Ÿæ±‡ç¼–ç¨‹åºï¼ˆ.sï¼‰
> * æ±‡ç¼–é˜¶æ®µï¼šå°†.sæ–‡ä»¶çš„æ±‡ç¼–ç¨‹åºç¿»è¯‘ä¸ºæœºå™¨ç ï¼Œç”Ÿæˆä¸€ç§**å¯é‡å®šä½ç›®æ ‡ç¨‹åº**ï¼Œæ–‡ä»¶æ ¼å¼ä¸º.o
> * é“¾æ¥é˜¶æ®µï¼šç¼–è¯‘è¿‡åçš„.oæ–‡ä»¶ç»ä¸æ˜¯ç‹¬ç«‹çš„ï¼Œå½¼æ­¤ä¹‹é—´å¾€å¾€å­˜åœ¨è°ƒç”¨å…³ç³»ï¼Œæ•…é€šå¸¸éœ€è¦å°†ä¸åŒçš„ç¨‹åºé“¾æ¥åœ¨ä¸€èµ·ï¼Œä½¿å¾—ä¸»è°ƒå‡½æ•°å¯ä»¥è°ƒç”¨åˆ°è¢«è°ƒå‡½æ•°ã€‚åˆ†ä¸ºé™æ€é“¾æ¥å’ŒåŠ¨æ€é“¾æ¥ä¸¤ç§ï¼Œä¹Ÿå°±æ˜¯åŠ¨æ€åº“å’Œé™æ€åº“ï¼Œé™æ€åº“çš„åç¼€ä¸€èˆ¬ä¸º.aï¼ŒåŠ¨æ€åº“çš„åç¼€ä¸€èˆ¬ä¸º.soï¼ˆè²Œä¼¼å¯ä»¥é²è½çš„è®¤ä¸ºjavaå±äºåŠ¨æ€é“¾æ¥ï¼‰
>
> å¸¸è§çš„ç›®æ ‡æ–‡ä»¶å½¢å¼
>
> * å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶ï¼šåŒ…å«äºŒè¿›åˆ¶ä»£ç ä¸æ•°æ®ï¼Œç”±æ±‡ç¼–å™¨äº§ç”Ÿï¼Œå¤šä¸ªå¯é‡å®šä½ç›®æ ‡æ–‡ä»¶ç»è¿‡é“¾æ¥å™¨ä¹‹åå½¢æˆå¯ä»¥è¢«è¿è¡Œçš„å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶
> * å¯æ‰§è¡Œç›®æ ‡æ–‡ä»¶ï¼šåŒ…å«äºŒè¿›åˆ¶ä»£ç å’Œæ•°æ®ï¼Œå¯ä»¥è¢«åŠ è½½å™¨ç›´æ¥æ‰§è¡Œã€‚
>
> **To be continued =>**

execåœ¨æ‰§è¡Œå®Œæˆè¿›ç¨‹ä¹‹åå¹¶ä¸ä¼šè¿”å›åˆ°è°ƒç”¨execçš„ç¨‹åºï¼Œè²Œä¼¼æ˜¯ä¼šåœ¨ELFæ–‡ä»¶å¤´æŒ‡æ˜çš„ä½ç½®æ‰§è¡Œã€‚ï¼ˆxv6ä¹¦è¿™é‡Œå†™çš„æ¯”è¾ƒè´¹è§£ï¼Œå°±å§‘ä¸”ç†è§£æˆï¼Œexecä¼šç”¨ELFæ–‡ä»¶å®Œå…¨æ›¿æ¢æ‰å½“å‰processçš„å†…å®¹ï¼ˆå½“ç„¶åœ¨åé¢çš„ç« èŠ‚ä¸­å¯ä»¥äº†è§£åˆ°ï¼Œå…¶å®å…¶ä¸­çš„**æ–‡ä»¶æ ‡è¯†ç¬¦**æ˜¯æ²¡æœ‰è¢«æ›¿æ¢æ‰çš„ï¼‰å°±å°†å¯¼è‡´å…¶è¿”å›å€¼ä½ç½®ï¼ˆç†åº”å†™åœ¨stackä¸­ï¼‰ä¹Ÿä¼šè¢«ä¿®æ”¹ï¼Œæœ€ç»ˆå¯¼è‡´processæ— æ³•è¿”å›åˆ°ä¸»è°ƒä½ç½®ï¼‰

`This fragment replaces the calling program with an instance of the program /bin/echo running with the argument list echo hello. `ï¼Œä¹¦ä¸­çš„è¿™éƒ¨åˆ†å†…å®¹æ„Ÿè§‰å°±æ˜¯åœ¨æš—ç¤ºè¿™ç§â€œæ´—å†…å­˜â€çš„æ„Ÿè§‰

execæ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œåˆ†åˆ«æ˜¯å‡½æ•°æ–‡ä»¶åå’Œstringå‚æ•°æ•°ç»„ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œstringæ•°ç»„çš„ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤ºè¢«è°ƒå‡½æ•°çš„åç§°ï¼Œæ‰€ä»¥ä¸€èˆ¬è¿™ä¸ªä¸å‘æŒ¥ä½œç”¨ã€‚

### Shellçš„æ‰§è¡Œï¼ˆå«æºç åˆ†æï¼‰

Shellä¸æ–­çš„æ¥æ”¶å‚æ•°å¹¶æ‰§è¡Œå‚æ•°ï¼Œå…¶å…·ä½“çš„æ‰§è¡Œå†…å®¹å¦‚ä¸‹

sh.cçš„mainå‡½æ•°

```c
int
main(void) {
    static char buf[100];
    int fd;

    // Ensure that three file descriptors are open.
    // ä¿è¯ä¸‰ä¸ªæœ€åŸºæœ¬çš„æ–‡ä»¶æ ‡è¯†ç¬¦éƒ½æ˜¯æ‰“å¼€çš„
    while ((fd = open("console", O_RDWR)) >= 0) {
        if (fd >= 3) {
            close(fd);
            break;
        }
    }

    // Read and run input commands.
    // è¯»å–å¹¶ä¸”æ‰§è¡Œè¾“å…¥çš„æŒ‡ä»¤
    while (getcmd(buf, sizeof(buf)) >= 0) {
        
        //åœ¨å•ç‹¬å¤„ç†cd æŒ‡ä»¤ï¼ŒåŸå› å‚è€ƒæ–‡ä»¶ç³»ç»Ÿéƒ¨åˆ†
        if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ') {
            // Chdir must be called by the parent, not the child.
            buf[strlen(buf) - 1] = 0;  // chop \n
            if (chdir(buf + 3) < 0)
                fprintf(2, "cannot cd %s\n", buf + 3);
            continue;
        }
        
        //è¿™é‡Œçš„fork1å¥½åƒæ˜¯ä¿è¯å¯ä»¥æ­£å¸¸forkçš„fork
        //å°±æ˜¯å°†å¼‚å¸¸çš„forkï¼ˆpid == -1ï¼‰ç›´æ¥panicæ‰
        //ä¿è¯è¿™é‡Œæ‹¿åˆ°çš„æ˜¯æ­£ç¡®çš„å­è¿›ç¨‹
        if (fork1() == 0)
            runcmd(parsecmd(buf));
        wait(0);
    }
    exit(0);
}
```

å¯ä»¥çœ‹åˆ°è°ƒç”¨æ ˆæŒ‡å‘äº†runcmdå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¥æ”¶ä¸€ä¸ªcmdç»“æ„ä½“ï¼Œçœ‹èµ·æ¥æ˜¯éœ€è¦å°†å…¥å‚é€šè¿‡parsecmdå‡½æ•°æ‰“åŒ…ä¸ºcmdç»“æ„ä½“ï¼Œç®€å•è¯´æ˜ä¸€ä¸‹cmdç»“æ„ä½“ï¼šcmdç»“æ„ä½“è²Œä¼¼åªæ˜¯å¯¹æŒ‡ä»¤è¿›è¡Œäº†ç®€å•çš„åˆ†ç±»ï¼Œå°†ä¸åŒçš„æŒ‡ä»¤å†™ä½œäº†ä¸åŒçš„typeï¼Œç”¨äºåœ¨execçš„æ—¶å€™æ‰§è¡Œ

é‡ç‚¹è¿˜æ˜¯åº”å½“ç€çœ¼äºruncmdå‡½æ•°ï¼Œä¸‹ä¸ºæºç åŠå…¶åˆ†æ

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºåœ¨ä¸Šæ–‡ä¸­å·²ç»è°ƒç”¨äº†forkå‡½æ•°ï¼Œè¿™é‡Œçš„æ‰§è¡Œå·²ç»åœ¨å­çº¿ç¨‹ä¸­äº†ï¼Œå·²ç»ä¸ç»´æŒshellçš„åŸå§‹è¿›ç¨‹ä¸å†æ˜¯åŒä¸€ä¸ªè¿›ç¨‹

```c
// Execute cmd.  Never returns.
void
runcmd(struct cmd *cmd) {
    int p[2];
    struct backcmd *bcmd;
    struct execcmd *ecmd;
    struct listcmd *lcmd;
    struct pipecmd *pcmd;
    struct redircmd *rcmd;

    if (cmd == 0)
        exit(1);

    switch (cmd->type) {
        default:
            panic("runcmd");

        case EXEC:
            ecmd = (struct execcmd *) cmd;
            //æ³¨æ„ï¼Œä¸‹é¢å¹¶ä¸æ˜¯æ„å‘³ç€execæ²¡æœ‰è¾“å…¥å‚æ•°å°±å°†ä¸æ‰§è¡Œ
            //å°±ç®—å‡½æ•°æ²¡æœ‰å…¥å‚ï¼Œæ¯”å¦‚åœ¨æ§åˆ¶æ¡è¾“å…¥catä¹‹åå›è½¦
            //å…¶string argsä¸­ä»ç„¶å­˜åœ¨ä¸€ä¸ªä¸å‡½æ•°åŒåçš„å‚æ•°
            //æ•…è¿™é‡Œçš„argv[0] == 0è¡¨ç¤ºæœ€åŸºç¡€çš„ç¬¬ä¸€ä¸ªå‚æ•°é”™è¯¯ï¼Œæ•…exit
            if (ecmd->argv[0] == 0)
                exit(1);
            exec(ecmd->argv[0], ecmd->argv);
            //è¿™é‡Œå¾ˆç»†èŠ‚ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹execæŒ‡ä»¤çš„è°ƒç”¨ç»“æœå¹¶ä¸ä¼šè¿”å›åˆ°ä¸»è°ƒå‡½æ•°ä¸­
            //å¦‚æœä¸‹é¢çš„å‡½æ•°æ‰§è¡Œäº†ï¼Œå°±å¿…ç„¶è¡¨ç¤ºexecæ‰§è¡Œé”™è¯¯
            //xv6è¿™é‡Œçš„å¤„ç†å°±æ˜¯é€šè¿‡æ ‡å‡†è¾“å‡ºæµæ ‡è¯†æ‰§è¡Œå¤±è´¥
            fprintf(2, "exec %s failed\n", ecmd->argv[0]);
            break;

        case REDIR:
            rcmd = (struct redircmd *) cmd;
            close(rcmd->fd);
            if (open(rcmd->file, rcmd->mode) < 0) {
                fprintf(2, "open %s failed\n", rcmd->file);
                exit(1);
            }
            runcmd(rcmd->cmd);
            break;
            
            ....çœç•¥éƒ¨åˆ†ä»£ç ....
    }
    exit(0);
}
```

éœ€è¦åé¢ç•™æ„çš„æ˜¯ï¼Œåœ¨execä¹‹å‰ï¼Œå­è¿›ç¨‹å¯ä»¥ä¿®æ”¹è‡ªå·±çš„æ–‡ä»¶æ ‡è¯†ç¬¦ï¼Œè¿™æ ·çš„ç»“æœæ˜¯å¯ä»¥å‡å°‘è¢«æ‰§è¡Œçš„fileæœ¬èº«çš„å‹åŠ›ï¼Œå®ƒä¸éœ€è¦å»å•ç‹¬å¤„ç†å¤šç§æ–‡ä»¶æ ‡è¯†ç¬¦çš„æƒ…å†µï¼Œå¯¹äºå®ƒæ¥è¯´ï¼Œæ–‡ä»¶æ ‡è¯†ç¬¦å°±æ˜¯æŠ½è±¡çš„æ ‡å‡†è¾“å…¥å’Œæ ‡å‡†è¾“å‡ºï¼Œç®—æ˜¯ä¸€å®šç¨‹åº¦ä¸Šçš„æŠ½è±¡ã€‚è¿™åŒæ—¶ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆforkå’Œexecä¸èƒ½åŒæ—¶æ‰§è¡Œçš„é‡è¦åŸå› 

æ¥ä¸‹æ¥å°†è¦ä»‹ç»æ–‡ä»¶æ ‡è¯†ç¬¦å’ŒIOï¼Œè¿™é‡Œç›²çŒœshellçš„å›æ˜¾æ˜¯é€šè¿‡IOæˆ–è€…pipeå®ç°çš„

## æ–‡ä»¶æ ‡è¯†ç¬¦ä¸I/O

æ–‡ä»¶æ ‡è¯†ç¬¦ï¼šFile Descriptorsï¼š

### ä¸‡ç‰©çš†æ–‡ä»¶

é¦–å…ˆéœ€è¦äº†è§£ä¸€ä¸ªæ¦‚å¿µï¼Œåœ¨Linuxæˆ–è€…Unix Likeçš„ç³»ç»Ÿä¸­ï¼Œä¸‡ç‰©çš†æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™é‡Œçš„æ–‡ä»¶æ ‡è¯†ç¬¦çš„ä½œç”¨è¿œæ¯”å®ƒçœ‹èµ·æ¥è¦å¤§ï¼Œå®é™…ä¸Šä¹Ÿæ˜¯å¦‚æ­¤ã€‚

ä¸€èˆ¬è€Œè¨€ï¼Œæ–‡ä»¶æ ‡è¯†ç¬¦0è¡¨ç¤ºæ ‡å‡†è¾“å…¥æµï¼Œæ–‡ä»¶æ ‡è¯†ç¬¦1è¡¨ç¤ºæ ‡å‡†è¾“å‡ºæµï¼Œæ–‡ä»¶æ ‡è¯†ç¬¦2è¡¨ç¤ºæ ‡å‡†é”™è¯¯è¾“å‡ºæµã€‚ç”¨äºå’Œfile descriptorsäº¤äº’çš„å‡½æ•°å¾€å¾€æ˜¯read or writeï¼Œopen or closeï¼Œå‰ä¸€å¯¹çš„ä½œç”¨ä¸ºï¼šä»æŒ‡å®šçš„è¾“å…¥æµè¯»å–ä¸€å®šé‡çš„æ•°æ®ï¼Œä»æŒ‡å®šçš„è¾“å‡ºæµè¾“å‡ºä¸€å®šçš„æ•°æ®ã€‚åè€…åˆ™æ˜¯æ‰“å¼€orå…³é—­ä¸€ä¸ªfdï¼ˆå…·ä½“çš„è§„åˆ™åç»­ä»‹ç»ï¼‰

æ€»ç»“çš„è¯´ï¼Œfdè”ç³»ç€ä¸€ä¸ªæ–‡ä»¶ï¼Œå¹¶ä¸”å†…éƒ¨å­˜åœ¨ä¸€ä¸ªoffsetï¼Œè¿™ä¸ªoffsetï¼Œfdå°†ä¼šä¾æ®offsetåœ¨æ–‡ä»¶çš„æŒ‡å®šä½ç½®è¯»å–å’Œå†™å…¥ã€‚



`The important thing to note in the code fragment is that cat doesnâ€™t know whether it is reading from a file, console, or a pipe. Similarly cat doesnâ€™t know whether it is printing to a console, a file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and file descriptor 1 is output allows a simple implementation of cat.`



è¿™æ®µåŸæ–‡çªå‡ºäº†fdçš„æŠ½è±¡æ€§ï¼Œå³fdå¹¶ä¸ä¸€å®šæŒ‡å‘çš„æ˜¯ä¸€æ®µtxt likeçš„æ–‡æœ¬ï¼Œå®ƒæ›´æœ‰å¯èƒ½æ˜¯pipeï¼Œconsoleç­‰ç­‰å…¶ä»–çš„ä¸œè¥¿ï¼Œä¸€æ–¹é¢ï¼Œè¿™ä½“ç°äº†ä¸‡ç‰©çš†æ–‡ä»¶çš„æŠ½è±¡ï¼Œä¸€æ–¹é¢ï¼Œè¿™æ–¹ä¾¿äº†catçš„ç¨‹åºè®¾è®¡ï¼Œä¹Ÿå°±æ˜¯è¯´ç¨‹åºçš„è®¾è®¡è€…å¹¶ä¸ç”¨äº†è§£å¦‚æœfdæ¥è‡ªpipeè¦æ€ä¹ˆåšï¼Œæ¥è‡ªconsoleè¦æ€ä¹ˆåšï¼Œå®ƒåªéœ€è¦å…³æ³¨è¾“å…¥å’Œè¾“å‡ºå°±å¯ä»¥äº†ï¼Œå…¶ä»–çš„å‡ä¸ä»–æ— å…³ã€‚

### openä¸closeçš„è§„åˆ™

ä½¿ç”¨closeå‡½æ•°å¯ä»¥æ”¾é£ä¸€ä¸ªfdï¼Œæ ‡è¯†å®ƒä¸ºå¯ç”¨ï¼Œä¹‹åå½“ä½¿ç”¨openå‡½æ•°æ‰“å¼€fileæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ†é…æœ€å°çš„fdç”¨äºæŒ‡å‘å¯¹åº”çš„æ–‡ä»¶ã€‚

`The close system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call (see below). A newly allocated file descriptor is always the lowest- numbered unused descriptor of the current process.`

### ä½¿ç”¨fdè¿›è¡ŒI/Oé‡å®šå‘

æ ¹æ®å·²çŸ¥ä¿¡æ¯ï¼Œexecä¼šæ´—æ‰å†…å­˜ï¼Œä½†æ˜¯å¹¶ä¸ä¼šå½±å“ç¨‹åºçš„æ–‡ä»¶æ ‡è¯†ç¬¦ï¼ˆ`The system call exec replaces the calling processâ€™s memory but
preserves its file table.`ï¼‰è¿™æ ·çš„è¯ï¼Œåœ¨forkä¹‹åï¼Œexecä¹‹å‰ï¼Œå°±å¯ä»¥æ ¹æ®çˆ¶è¿›ç¨‹çš„fdä¿®æ”¹å­è¿›ç¨‹çš„fdï¼Œä¹‹åæ‰§è¡Œexecï¼Œå®ç°I/Oçš„é‡å®šå‘ã€‚ï¼ˆè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆforkå’Œexecä¸åº”è¯¥åŒæ—¶æ‰§è¡Œçš„åŸå› ï¼‰ã€‚ä¸‹ä¸ºä¾‹å­

```c
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
	close(0);//åœ¨å­è¿›ç¨‹ä¸­å…³é—­æ ‡å‡†è¾“å…¥æµ
   //æ ¹æ®closeå’Œopençš„è§„åˆ™ï¼Œè¿™é‡Œæ˜¯å°†æ ‡å‡†è¾“å…¥æµé‡å®šå‘åˆ°input.txt
	open("input.txt", O_RDONLY);
   //é‡å®šå‘ä¹‹åå†æ‰§è¡Œexecï¼Œå¹¶ä¸ä¼šæ´—æ‰fdï¼Œæ•…å¯ä»¥å®ç°é‡å®šå‘
	exec("cat", argv);
}
```

I/Oé‡å®šå‘çš„å¥½å¤„æ˜¯ä»€ä¹ˆï¼Ÿ

`the shell has a chance to redirect the childâ€™s I/O without disturbing the I/O setup of the main shell. `å³å¯ä»¥åœ¨ä¸å¹²æ‰°ä¸»ç¨‹ä¸­åŸæœ¬çš„fdæŒ‡å‘çš„æƒ…å†µä¸‹ä¿®æ­£é€»è¾‘ï¼Œå¯ä»¥æ»¡è¶³ä¸€å®šçš„æŠ½è±¡åŸåˆ™ã€‚

### dupæŒ‡ä»¤

dupä¼šç”Ÿæˆä¸€ä¸ªå’Œè¾“å…¥fdæŒ‡å‘åŒä¸€ä¸ªfileçš„æ–‡ä»¶ï¼Œå¹¶ä¸”äºŒè€…å…±äº«offset

```c
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

æœ€ç»ˆçš„ç»“æœå°†æ˜¯hello world\nï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç”¨ä»»æ„å…¶ä»–æ–¹æ³•æ‰“å¼€çš„fdå‡ä¸å¯èƒ½å…±äº«offsetï¼Œå°±ç®—æ˜¯å¯¹åŒä¸€ä¸ªfile openä¸¤æ¬¡ï¼Œæœ€ç»ˆå¾—åˆ°çš„ä¸¤ä¸ªfdä¹Ÿä¸ä¼šå…±äº«offsetï¼Œå¦‚æœæ˜¯å…¶ä»–çš„æƒ…å†µï¼Œæœ€ç»ˆçš„ç»“æœåªä¼šæ˜¯world\n

è¿™æ ·çš„ä½œç”¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ



`Dup allows shells to implement commands like this: ls existing-file non-existing-file > tmp1 2>&1. The 2>&1 tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1.`



ä¸Šæ–‡çš„å¤§ä½“å«ä¹‰æ˜¯ï¼šè¿™æ ·çš„è¯æ”¯æŒåŒæ—¶å°†å¤šä¸ªfdçš„å†…å®¹çŒå…¥åŒä¸€ä¸ªè¾“å‡ºä¹‹ä¸­ï¼Œä¾‹å¦‚å°†æŠ¥é”™ä¿¡æ¯å’Œæ­£ç¡®ä¿¡æ¯åŒæ—¶çŒå…¥ä¸€ä¸ªlogæ–‡ä»¶ä¹‹ä¸­ï¼Œå¹¶ä¸”ä¿è¯äºŒè€…çš„offsetç›¸åŒï¼Œä¸ä¼šäº’ç›¸è¦†ç›–



## pipe ç®¡é“

ç®¡é“æ˜¯ä¸€ç»„æ–‡ä»¶æ ‡è¯†ç¬¦ï¼Œå…¶ä¸­ä¸€ä¸ªçš„è¾“å…¥å¯¹åº”åˆ°å¦ä¸€ä¸ªçš„è¾“å‡ºï¼Œæ„æˆåŒå·¥é€šä¿¡çš„ä¸¤æ¡é“¾è·¯ï¼Œé€šè¿‡æ­¤å¯ä»¥å®ç°ä¸åŒprocessä¹‹é—´çš„é€šä¿¡ã€‚å…·ä½“çš„ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹

```c
int p[2];//ç”¨äºæ‰¿è½½pipeä¸¤ä¸ªæ–‡ä»¶æ ‡è¯†ç¬¦çš„æ•°ç»„
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);//åŸºäºpå»ºç«‹ä¸€ä¸ªpipe
if(fork() == 0) {
	close(0);//å°†æ ‡å‡†è¾“å…¥æµclose
	dup(p[0]);//å¤åˆ»ä¸€ä¸ªp[0]ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™ç©ºé—²çš„æ˜¯0ï¼Œæ‰€ä»¥æ˜¯å°†0æŒ‡å‘p[0]
	close(p[0]);//å…³é—­ä¸¤ä¸ªpipe
	close(p[1]);
    //ç›®å‰0æŒ‡å‘p[0]çš„dupï¼Œä¹Ÿå°±æ˜¯pipeçš„è¾“å‡ºç«¯ï¼ˆread sideï¼‰
    //ç¨‹åºçš„æ ‡å‡†è¾“å…¥æµå°†æŒ‡å‘pipeçš„è¾“å‡ºç«¯ï¼ˆread sideï¼‰
    //ä¹Ÿå°±æ˜¯å°†ç®¡é“çš„è¾“å‡ºçŒå…¥å­è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥
	exec("/bin/wc", argv);
} else {
    //çˆ¶è¿›ç¨‹ä¸­æœ‰å’Œå­è¿›ç¨‹å®Œå…¨ç›¸åŒçš„æ–‡ä»¶æ ‡è¯†ç¬¦
    //ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œçš„på’Œå­è¿›ç¨‹å®Œå…¨ç›¸åŒ
	close(p[0]);//å…³é—­çˆ¶è¿›ç¨‹ä¸­ç®¡é“çš„readç«¯
	write(p[1], "hello world\n", 12);//å‘ç®¡é“çš„writeç«¯çŒå…¥å­—ç¬¦ä¸²
	close(p[1]);//å…³é—­ç®¡é“
}
```

è¿™é‡Œæ¯”è¾ƒå€¼å¾—ç•™æ„çš„æ˜¯ç®¡é“ä»€ä¹ˆæ—¶å€™å¯ä»¥readå‡ºä¸œè¥¿ï¼ŒåŸä¹¦ä¸­æ˜¯è¿™æ ·ç»™å‡ºçš„



`If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed`



ä¹Ÿå°±æ˜¯å†™å…¥äº†æ•°æ®æˆ–è€…ç­‰åˆ°æ•´ä¸ªwrite sideè¢«å…³é—­äº†ï¼Œéƒ½å°†å¯¼è‡´readè¢«å”¤é†’ï¼Œè¿™ä¹Ÿæ˜¯ä¸Šé¢çš„é‚£å¥—ä»£ç ä¸­æœ€ç»ˆå…³é—­pipe[1]çš„åŸå› ä¹‹ä¸€ã€‚

### ç®¡é“ç¬¦çš„å®ç°

å½“ç„¶ï¼Œåœ¨å®é™…çš„shellä½¿ç”¨ä¸­ï¼Œå¹¶ä¸æ˜¯é pipeæŒ‡ä»¤å»ºç«‹pipeçš„ï¼Œç°ä»£çš„shellå‡å¯ä»¥é€šè¿‡ç®¡é“ç¬¦â€œ|â€å»å»ºç«‹pipeï¼Œå…¶å…·ä½“çš„é€»è¾‘ä»£ç å®ç°å¦‚ä¸‹

```c
case PIPE:
//æ£€æµ‹åˆ°æ˜¯PIPEç±»å‹çš„è¯­å¥
pcmd = (struct pipecmd *) cmd;
if (pipe(p) < 0)//å°è¯•å»ºç«‹ç®¡é“ï¼Œå¦‚æœå»ºç«‹å¤±è´¥åˆ™panic
    panic("pipe");
if (fork1() == 0) {
    //å¼€è¾Ÿå­è¿›ç¨‹1
    close(1);//å…³é—­æ ‡å‡†è¾“å‡ºæµ
    dup(p[1]);//ä½¿å¾—1æŒ‡å‘ç®¡é“çš„write sideï¼Œä¹Ÿå°±æ˜¯å°†æ ‡å‡†è¾“å‡ºæµçŒå…¥ç®¡é“çš„è¾“å…¥ç«¯
    //å…³é—­ç®¡é“
    close(p[0]);
    close(p[1]);
    //åœ¨å­è¿›ç¨‹1ä¸­è¿è¡Œå·¦ä¾§æŒ‡ä»¤
    //æŒ‡ä»¤çš„è¾“å‡º->æ ‡å‡†è¾“å‡º->ç®¡é“write side
    runcmd(pcmd->left);
}
if (fork1() == 0) {
    //å¼€è¾Ÿå­è¿›ç¨‹2
    close(0);//å…³é—­æ ‡å‡†è¾“å…¥æµ
    dup(p[0]);//ä½¿å¾—0æŒ‡å‘ç®¡é“çš„read sideï¼Œä¹Ÿå°±æ˜¯å°†ç®¡é“çš„è¾“å‡ºçŒå…¥æ ‡å‡†è¾“å…¥æµ
    //å…³é—­ç®¡é“
    close(p[0]);
    close(p[1]);
    //æ‰§è¡Œå³ä¾§æŒ‡ä»¤
    //ç®¡é“è¾“å‡º->æ ‡å‡†è¾“å…¥->æŒ‡ä»¤çš„è¾“å…¥
    runcmd(pcmd->right);
}
close(p[0]);
close(p[1]);
wait(0);
wait(0);
break;
```

æˆ‘ä¸å¤ªç¡®å®šä¸Šè¿°ä»£ç æ˜¯å¦‚ä½•ä¿è¯ä»£ç æ‰§è¡Œçš„é¡ºåºæ€§çš„ï¼Œä¸è¿‡çŒœæµ‹åº”è¯¥æ˜¯å³ä¾§ä»£ç åœ¨æ²¡æœ‰è¾“å…¥æ—¶ä¸ä¼šæ‰§è¡Œ

å½“ç„¶ï¼Œåœ¨å³ä¾§runcmdçš„æ—¶å€™ï¼Œè¿™é‡Œçš„cmdä¾æ—§å¯ä»¥æ˜¯ä¸€ä¸ªpcmdï¼ˆå«ç®¡é“ç¬¦çš„cmdcdï¼‰



`The right end of the pipeline may be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new child
processes (one for b and one for c). `



è¿™æ ·çš„è¯å°†ä¼šå½¢æˆä¸€ä¸ªäºŒå‰æ ‘ï¼Œå…¶ç»“æ„å¤§è‡´å¦‚ä¸‹



`Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete.`

> äºŒå‰æ ‘çš„å¶å­ä¸ºä¸€æ¡ä¸€æ¡çš„æŒ‡ä»¤ï¼ˆæˆ–è®¸æˆ‘åº”è¯¥è¯´ï¼šä¸å«ç®¡é“ç¬¦çš„æŒ‡ä»¤ï¼‰ï¼Œè€Œå†…éƒ¨èŠ‚ç‚¹ä¸ºä¸€ä¸ªåˆä¸€ä¸ªçš„è¿›ç¨‹ï¼Œè¿™ä¸ªè¿›ç¨‹åœ¨ç­‰å¾…å…¶å·¦å³å­èŠ‚ç‚¹å®Œæˆå·¥ä½œï¼Œå…¶å·¦å³å­èŠ‚ç‚¹å¯ä»¥æ˜¯ä¸å«ç®¡é“ç¬¦çš„æŒ‡ä»¤ï¼Œä¹Ÿå¯ä»¥æ˜¯è¿›ä¸€æ­¥åˆ’åˆ†å‡ºçš„processã€‚

å› ä¸ºè¿™æ£µæ ‘æ˜¯å³åˆ’åˆ†çš„ï¼Œæ‰€ä»¥è¯´ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘éƒ½æ˜¯ä¸€æ¡å•æŒ‡ä»¤ã€‚

å…¶å®è¿™é‡Œæœ‰ä¸€ä¸ªå¾ˆæœ‰è¶£çš„é—®é¢˜ï¼Œä¸ºä»€ä¹ˆè¿™ç§åˆ’åˆ†æ˜¯pipelineä»¥å³çš„ï¼Œè€Œä¸æ˜¯ä»¥å·¦ï¼Ÿthe bookç»™å‡ºçš„ç»“è®ºæ˜¯è¿™æ ·æ˜¾ç„¶ä¼šå¢åŠ å¤æ‚åº¦



`In principle, one could have the interior nodes run the left end of a pipeline, but doing so correctly would complicate the implementation.`



ä¸ªäººè®¤ä¸ºè¿™é‡Œçš„åŸå› æ˜¯ï¼Œå·¦åˆ’åˆ†å’Œç®¡é“è‡ªå·¦å‘å³æ‰§è¡Œçš„é€»è¾‘ç›¸æ‚–ï¼Œå¦‚æœæ˜¯å·¦åˆ’åˆ†ï¼ŒäºŒå‰æ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½å°†æœ‰ä¸€ä¸ªå·¨å¤§çš„å·¦å­æ ‘ï¼Œè€Œç¬¬ä¸€ä¸ªéœ€è¦æ‰§è¡Œçš„æŒ‡ä»¤æ˜¾ç„¶åœ¨æœ€å·¦ä¾§ï¼Œå¯»æ‰¾è¿™æ¡æŒ‡ä»¤çš„è¿‡ç¨‹æ˜¾ç„¶ä¼šæ¯”å³åˆ’åˆ†å¾—åˆ°çš„äºŒå‰æ ‘å¤æ‚çš„å¤šã€‚

## æ–‡ä»¶ç³»ç»Ÿ

### Device File

Linuxä¸‡ç‰©çš†æ–‡ä»¶ï¼Œå°±ç®—æ˜¯ä¸ç¡¬ä»¶è®¾å¤‡çš„äº¤äº’ï¼Œåœ¨ç³»ç»Ÿä¸­ä¹Ÿæ˜¯é€šè¿‡fileå®ç°çš„ï¼Œä¸å¸¸è§„çš„æ–‡ä»¶ä¸åŒï¼Œè¿™ç§æ–‡ä»¶ç§°ä¸º`device file`ï¼Œä½¿ç”¨mknodæŒ‡ä»¤å¯ä»¥åˆ›å»ºdevice fileï¼Œå…·ä½“ä½¿ç”¨å¦‚ä¸‹

```c
mknod("/console", 1, 1);
```

`Associated with a device file are the major and minor device numbers (the two arguments to mknod), which uniquely identify a kernel device.`

> Linuxä¸‹çš„device fileç›¸å…³ï¼š
>
> å‚è€ƒæ–‡ç« ï¼š[Linux Kernel Study : Device File](https://linux-kernel-labs.github.io/refs/heads/master/labs/device_drivers.html)
>
> é¦–å…ˆï¼Œåº”è¯¥å†·é™çš„è®¤è¯†åˆ°ï¼Œç”¨fileè¡¨ç¤ºç¡¬ä»¶è®¾å¤‡æ˜¾ç„¶åªæ˜¯ä¸€ç§æŠ½è±¡ï¼Œå¯¹device fileçš„è®¿é—®å°†ä¼šè¢«osé‡å®šå‘åˆ°å¯¹åº”çš„ç¡¬ä»¶è®¾å¤‡
>
> These files are grouped into the /dev directory, and system calls `open`, `read`, `write`, `close`, `lseek`, `mmap` etc. are redirected by the operating system to the device driver associated with the physical device
>
> UNIX likeçš„OSä¸­ï¼Œdevice fileåˆ†ä¸ºä¸¤ç§ï¼ŒCharacter device file & Block device fileï¼ŒLinux Kernelçš„æ–‡æ¡£ä¸­ï¼ŒäºŒè€…çš„åŒºåˆ«å¦‚ä¸‹ï¼š
>
> This division is done by the speed, volume and way of organizing the data to be transferred from the device to the system and vice versa
>
> ç»†ğŸ”’çš„è¯
>
> * Character Device Fileï¼šé€Ÿåº¦æ…¢ï¼Œæ§åˆ¶å°‘é‡çš„æ•°æ®ï¼Œå¹¶ä¸”I/Oæ•°æ®å¾ˆå°‘æ¶‰åŠåˆ°éšæœºå¯»å€ï¼ŒExamples are devices such as keyboard, mouse, serial ports, sound card, joystick. ä¸€èˆ¬ä¸å®ƒä»¬çš„äº¤äº’å°±æ˜¯ä¸€ä¸ªbyteæ¥ç€ä¸€ä¸ªbyteã€‚
> * Block Device Fileï¼šæ•°æ®æˆå—ï¼Œä½“ç§¯å¤§ï¼Œå…¶ä¸­ç»å¸¸å‘ç”Ÿå¯»å€æ“ä½œï¼ˆåŸæ–‡ä¸­æ­¤å¤„æ˜¯search is commonï¼‰ï¼ŒExamples of devices that fall into this category are hard drives, cdroms, ram disks, magnetic tape drives. è¿™äº›device fileçš„è¯»å†™ä¸€èˆ¬æ˜¯æ•°æ®å—çº§åˆ«ï¼Œè€Œébyte by byte
>
> Linuxä¸ºä¸¤ç§ä¸åŒç±»å‹çš„æ–‡ä»¶æä¾›äº†ä¸åŒçš„Apiã€‚
>
> åœ¨UNIXä¸­ï¼ŒDevice Fileé€šè¿‡ä¸¤ä¸ªå›ºå®šçš„æ•°å­—ï¼ˆMajor & Minorï¼‰è¿›è¡ŒåŒºåˆ†ï¼ŒLinuxç»§æ‰¿äº†è¿™ä¸ªä¼ ç»Ÿï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªæ•°å­—å˜å¾—å¯å˜äº†ï¼ŒMajorç”¨æ¥åŒºåˆ†Deviceç±»å‹ï¼Œeg: Disk, serial ...ï¼ŒMinorç”¨äºåŒºåˆ†å…·ä½“çš„è®¾å¤‡ï¼Œä¹Ÿå°±æ˜¯åœ¨å¤§ç±»ä¸‹çš„å…·ä½“è®¾å¤‡åŒºåˆ†ã€‚

fstatå‡½æ•°å¯ä»¥æ‰¾åˆ°æ–‡ä»¶æ ‡è¯†ç¬¦æ‰€åŒ…å«çš„æ–‡ä»¶ä¿¡æ¯ï¼Œå…·ä½“çš„ä¿¡æ¯å°±æ˜¯struct statï¼Œå…·ä½“çš„ç»“æ„ä½“ä»£ç å¦‚ä¸‹

```c
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```

### inode

åœ¨the bookä¸­å¹¶æ²¡æœ‰å¯¹inodeåšå‡ºè¯¦ç»†ä»‹ç»ï¼Œè¿™é‡Œ çš„å†…å®¹æ˜¯å‚è€ƒ[Linux Kernel Study : File System 2](https://linux-kernel-labs.github.io/refs/heads/master/labs/filesystems_part2.html)è€Œæ¥ï¼Œé¢å‘çš„æ˜¯Linuxï¼Œåœ¨xv6ä¸­ä¸ä¸€å®šå…·å¤‡ä»¥ä¸‹æ€§è´¨ã€‚

LKS FS2ä¸­å¯¹inodeçš„ä»‹ç»å¦‚ä¸‹

An inode uniquely identifies a file on disk and holds information about it (uid, gid, access rights, access times, pointers to data blocks, etc.). An important aspect is that an inode does not have information about the file name (it is retained by the associated `struct dentry` structure).

å¤§è‡´ç¿»è¯‘å¦‚ä¸‹ï¼šinodeæ˜¯metadataï¼ˆå…ƒæ•°æ®ï¼‰ï¼ŒåŒ…å«ç€æ•°æ®çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯æ•°æ®åœ¨diskä¸Šçš„å”¯ä¸€æ ‡è¯†ï¼Œè®¿é—®æƒé™ç­‰ç­‰ã€‚ï¼ˆå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œinodeä¸­å¹¶æ²¡æœ‰ç¼“å­˜æ–‡ä»¶çš„åç§°ï¼‰

æ–‡ä»¶ä¸æ–‡ä»¶æ ‡è¯†ç¬¦æ˜¯ä¸¤ä¸ªæ¦‚å¿µï¼Œä¹‹å‰çš„çŸ¥è¯†å‘Šè¯‰æˆ‘ä»¬ï¼ŒåŒä¸€ä¸ªæ–‡ä»¶å¯ä»¥è¢«openå¤šæ¬¡ï¼ˆæ–‡ä»¶è¢«opençš„æ ‡å¿—å°±æ˜¯æœ‰processä¸­çš„æ–‡ä»¶æ ‡è¯†ç¬¦å¯¹åº”ä¹‹ï¼‰ï¼Œæ¯è¢«openä¸€æ¬¡ï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªstruct  fileï¼Œè¿™ä¸ªstruct fileå°†ä¼šå’Œinodeå¯¹åº”ï¼Œä¹Ÿå°±æ˜¯è¯´inodeå¯ä»¥ä¸å¤šä¸ªï¼ˆzero or moreï¼‰struct fileå»ºç«‹è”ç³»ï¼ˆæ¯•ç«Ÿä¸€ä¸ªinodeå¯ä»¥è¢«å¤šä¸ªè¿›ç¨‹openå¤šæ¬¡ï¼‰

### link

å½“æŸä¸€ä¸ªæ–‡ä»¶åœ¨ä¸åŒè·¯å¾„ä¸‹å‡éœ€è¦è¢«ä½¿ç”¨æ—¶ï¼Œå¹¶ä¸éœ€è¦åœ¨æ¯ä¸€ä¸ªè·¯å¾„ä¸‹å‡å¤åˆ¶ä¸€ä»½ï¼Œå¯ä»¥é€šè¿‡linkå»ºç«‹ä¸€ä¸ªæ­¤æ–‡ä»¶çš„åŒæ­¥é“¾æ¥ï¼Œä¾›åœ¨ä¸åŒè·¯å¾„ä¸‹ä½¿ç”¨æ­¤æ–‡ä»¶ï¼Œæ–‡ä»¶æœ¬èº«ä¸æ–‡ä»¶çš„linkå¯ä»¥æ‹¥æœ‰ä¸åŒçš„åå­—ã€‚

`Each inode is identified by a unique inode number. After the code sequence above, it is possible to determine that a and b refer to the same underlying contents by inspecting the result of fstat: both will return the same inode number (ino), and the nlink count will be set to 2`

ä¸Šé¢æ˜¯è¯´ï¼šé€šè¿‡linkå½¢æˆçš„æ–‡ä»¶å°†ä¼šæŒ‡å‘åŒä¸€ä¸ªfileå”¯ä¸€æ ‡è¯†ï¼Œä¹Ÿå°±æ˜¯inoï¼Œè¿™ä¸ªinoçš„linkæ•°é‡ï¼ˆnlinkï¼‰å°†ä¼šå˜ä¸º2ï¼Œå€¼å¾—å…³æ³¨çš„æ˜¯ï¼Œå°±ç®—ä¸é€šè¿‡linkæŒ‡ä»¤å»ºç«‹é“¾æ¥ï¼Œå•çº¯çš„é€šè¿‡openå»ºç«‹ä¸€ä¸ªæ–‡ä»¶åŒæ ·ä¹Ÿä¼šäº§ç”Ÿlinkï¼Œ`open("a", O_CREATE|O_WRONLY);`ä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªåä¸ºaçš„linkã€‚

å½“ä¸€ä¸ªinodeçš„nlinkå½’é›¶ï¼Œå¹¶ä¸”å°šæœªæœ‰ç¨‹åºåœ¨ä½¿ç”¨å®ƒï¼Œå°†ä¼šè¢«æ¸…é™¤ï¼Œä¸‹é¢è¿™è¡Œä»£ç å¯ä»¥ç”Ÿæˆä¸€ä¸ªæ— åçš„inodeï¼Œå¹¶ä¸”æ­¤inodeå°†ä¼šåœ¨ç¨‹åºç»ˆç»“ä¹‹åè¢«å›æ”¶

```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œinodeçš„linkï¼ˆæˆ–è€…è¯´åå­—ï¼‰å¹¶ä¸æ˜¯ä½¿ç”¨inodeçš„å”¯ä¸€æ–¹æ³•ï¼Œæ¯”å¦‚ä¸Šè¿°ä»£ç ä¸­ï¼Œfdå°±æ˜¯åœ¨unlinkä¹‹åä½¿ç”¨æ­¤inodeçš„è·¯å¾„

è¿˜æœ‰ä¸€ä¸ªå¾ˆæœ‰è¶£çš„äº‹æƒ…ï¼ŒcdæŒ‡ä»¤æ˜¯å°‘æ•°å‡ ä¸ªshellä¸forkä¹‹åæ‰§è¡Œçš„æŒ‡ä»¤ï¼ŒåŸå› åœ¨äºcdéœ€è¦ä¿®æ”¹shellè¿›ç¨‹è‡ªèº«çš„æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœforkä¹‹åæ‰§è¡Œï¼Œæ˜¾ç„¶å°±æ— æ³•è¾¾åˆ°æ›´æ”¹shellè‡ªèº«è·¯å¾„çš„åˆè¡·ã€‚

```c
// Read and run input commands.
// è¯»å–å¹¶ä¸”æ‰§è¡Œè¾“å…¥çš„æŒ‡ä»¤
while (getcmd(buf, sizeof(buf)) >= 0) {

    //å•ç‹¬å¤„ç†cd æŒ‡ä»¤
    if (buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' ') {
        // Chdir must be called by the parent, not the child.
        buf[strlen(buf) - 1] = 0;  // chop \n
        if (chdir(buf + 3) < 0)
            fprintf(2, "cannot cd %s\n", buf + 3);
        continue;
    }
}
exit(0);
```

> Linuxçš„link
>
> å‚è€ƒæ–‡ç« ï¼š[Linux Kernel Study : File System 2  ](https://linux-kernel-labs.github.io/refs/heads/master/labs/filesystems_part2.html)  [Linuxç¡¬é“¾æ¥å’Œè½¯è¿æ¥çš„åŒºåˆ«ä¸æ€»ç»“ - Hsiaçš„åšå®¢ ](https://xzchsia.github.io/2020/03/05/linux-hard-soft-link/)
>
> å¦‚æœlinkå’Œæºæ–‡ä»¶çš„inodeç›¸åŒï¼Œåˆ™ä¸ºç¡¬é“¾æ¥ï¼Œå…·æœ‰ä»¥ä¸‹æ€§è´¨
>
> - åˆ é™¤ç¡¬é“¾æ¥æ–‡ä»¶æˆ–è€…åˆ é™¤æºæ–‡ä»¶ä»»æ„ä¹‹ä¸€ï¼Œæ–‡ä»¶å®ä½“å¹¶æœªè¢«åˆ é™¤ï¼Œåªæœ‰åˆ é™¤äº†æºæ–‡ä»¶å’Œæ‰€æœ‰å¯¹åº”çš„ç¡¬é“¾æ¥æ–‡ä»¶ï¼Œæ–‡ä»¶å®ä½“æ‰ä¼šè¢«åˆ é™¤ï¼Œå¯ä»¥é€šè¿‡ç»™æ–‡ä»¶è®¾ç½®ç¡¬é“¾æ¥æ–‡ä»¶æ¥é˜²æ­¢é‡è¦æ–‡ä»¶è¢«è¯¯åˆ ï¼›
> - ç¡¬é“¾æ¥æ–‡ä»¶æ˜¯æ™®é€šæ–‡ä»¶ï¼Œå¯ä»¥ç”¨rmåˆ é™¤ï¼›
> - å¯¹äºé™æ€æ–‡ä»¶ï¼ˆæ²¡æœ‰è¿›ç¨‹æ­£åœ¨è°ƒç”¨ï¼‰ï¼Œå½“ç¡¬é“¾æ¥æ•°ä¸º0æ—¶æ–‡ä»¶å°±è¢«åˆ é™¤ã€‚æ³¨æ„ï¼šå¦‚æœæœ‰è¿›ç¨‹æ­£åœ¨è°ƒç”¨ï¼Œåˆ™æ— æ³•åˆ é™¤æˆ–è€…å³ä½¿æ–‡ä»¶åè¢«åˆ é™¤ä½†ç©ºé—´ä¸ä¼šé‡Šæ”¾ã€‚
>
> å¦‚ä¸Šæ–‡æ‰€è¯‰ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ–‡ä»¶å°±ç®—ä¸é€‚ç”¨lnæŒ‡ä»¤å»ºç«‹linkï¼Œä¹Ÿä¼šè‡ªç„¶çš„å…·æœ‰ä¸€ä¸ªlink
>
> å¦‚æœlinkå’Œæºæ–‡ä»¶çš„inodeä¸ç›¸åŒï¼Œæ˜¯é€šè¿‡blockè®°å½•äº†æºæ–‡ä»¶ä½ç½®ï¼Œä¹‹åé‡å®šå‘è¿‡å»çš„ï¼Œåˆ™ä¸ºè½¯è¿æ¥ï¼Œå…·æœ‰ä»¥ä¸‹æ€§è´¨
>
> - è½¯é“¾æ¥ç±»ä¼¼windowsç³»ç»Ÿçš„å¿«æ·æ–¹å¼ï¼›è½¯é“¾æ¥é‡Œé¢å­˜æ”¾çš„æ˜¯æºæ–‡ä»¶çš„è·¯å¾„ï¼ŒæŒ‡å‘æºæ–‡ä»¶ï¼›
> - åˆ é™¤æºæ–‡ä»¶ï¼Œè½¯é“¾æ¥ä¾ç„¶å­˜åœ¨ï¼Œä½†æ— æ³•è®¿é—®æºæ–‡ä»¶å†…å®¹ï¼›
> - è½¯é“¾æ¥å’Œæºæ–‡ä»¶æ˜¯ä¸åŒçš„æ–‡ä»¶ï¼Œ**æ–‡ä»¶ç±»å‹ä¹Ÿä¸åŒ**ï¼Œinodeå·ä¹Ÿä¸åŒï¼›
> - è½¯é“¾æ¥çš„æ–‡ä»¶ç±»å‹æ˜¯â€œlâ€ï¼Œå¯ä»¥ç”¨rmåˆ é™¤ã€‚

